{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nvar _extends3 = _interopRequireDefault(require('babel-runtime/helpers/extends'));\n\nvar _classCallCheck3 = _interopRequireDefault(require('babel-runtime/helpers/classCallCheck'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n/**\n * A utility for resolving and subscribing to the results of a fragment spec\n * (key -> fragment mapping) given some \"props\" that determine the root ID\n * and variables to use when reading each fragment. When props are changed via\n * `setProps()`, the resolver will update its results and subscriptions\n * accordingly. Internally, the resolver:\n * - Converts the fragment map & props map into a map of `Selector`s.\n * - Removes any resolvers for any props that became null.\n * - Creates resolvers for any props that became non-null.\n * - Updates resolvers with the latest props.\n *\n * This utility is implemented as an imperative, stateful API for performance\n * reasons: reusing previous resolvers, callback functions, and subscriptions\n * all helps to reduce object allocation and thereby decrease GC time.\n *\n * The `resolve()` function is also lazy and memoized: changes in the store mark\n * the resolver as stale and notify the caller, and the actual results are\n * recomputed the first time `resolve()` is called.\n */\n\n\nvar RelayModernFragmentSpecResolver = function () {\n  function RelayModernFragmentSpecResolver(context, fragments, props, callback) {\n    var _this = this;\n\n    (0, _classCallCheck3['default'])(this, RelayModernFragmentSpecResolver);\n\n    this._onChange = function () {\n      _this._stale = true;\n\n      if (typeof _this._callback === 'function') {\n        _this._callback();\n      }\n    };\n\n    this._callback = callback;\n    this._context = context;\n    this._data = {};\n    this._fragments = fragments;\n    this._props = props;\n    this._resolvers = {};\n    this._stale = false;\n    this.setProps(props);\n  }\n\n  RelayModernFragmentSpecResolver.prototype.dispose = function dispose() {\n    for (var _key in this._resolvers) {\n      if (this._resolvers.hasOwnProperty(_key)) {\n        disposeCallback(this._resolvers[_key]);\n      }\n    }\n  };\n\n  RelayModernFragmentSpecResolver.prototype.resolve = function resolve() {\n    if (this._stale) {\n      // Avoid mapping the object multiple times, which could occur if data for\n      // multiple keys changes in the same event loop.\n      var prevData = this._data;\n      var nextData = void 0;\n\n      for (var _key2 in this._resolvers) {\n        if (this._resolvers.hasOwnProperty(_key2)) {\n          var resolver = this._resolvers[_key2];\n          var prevItem = prevData[_key2];\n\n          if (resolver) {\n            var nextItem = resolver.resolve();\n\n            if (nextData || nextItem !== prevItem) {\n              nextData = nextData || (0, _extends3['default'])({}, prevData);\n              nextData[_key2] = nextItem;\n            }\n          } else {\n            var prop = this._props[_key2];\n\n            var _nextItem = prop !== undefined ? prop : null;\n\n            if (nextData || !require('./isScalarAndEqual')(_nextItem, prevItem)) {\n              nextData = nextData || (0, _extends3['default'])({}, prevData);\n              nextData[_key2] = _nextItem;\n            }\n          }\n        }\n      }\n\n      this._data = nextData || prevData;\n      this._stale = false;\n    }\n\n    return this._data;\n  };\n\n  RelayModernFragmentSpecResolver.prototype.isLoading = function isLoading() {\n    for (var _key3 in this._resolvers) {\n      if (this._resolvers.hasOwnProperty(_key3) && this._resolvers[_key3] && this._resolvers[_key3].isLoading()) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  RelayModernFragmentSpecResolver.prototype.setCallback = function setCallback(callback) {\n    this._callback = callback;\n  };\n\n  RelayModernFragmentSpecResolver.prototype.setProps = function setProps(props) {\n    var selectors = require('./RelayModernSelector').getSelectorsFromObject(this._context.variables, this._fragments, props);\n\n    for (var _key4 in selectors) {\n      if (selectors.hasOwnProperty(_key4)) {\n        var selector = selectors[_key4];\n        var resolver = this._resolvers[_key4];\n\n        if (selector == null) {\n          if (resolver != null) {\n            resolver.dispose();\n          }\n\n          resolver = null;\n        } else if (Array.isArray(selector)) {\n          if (resolver == null) {\n            resolver = new SelectorListResolver(this._context.environment, selector, this._onChange);\n          } else {\n            !(resolver instanceof SelectorListResolver) ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'RelayModernFragmentSpecResolver: Expected prop `%s` to always be an array.', _key4) : require('fbjs/lib/invariant')(false) : void 0;\n            resolver.setSelectors(selector);\n          }\n        } else {\n          if (resolver == null) {\n            resolver = new SelectorResolver(this._context.environment, selector, this._onChange);\n          } else {\n            !(resolver instanceof SelectorResolver) ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'RelayModernFragmentSpecResolver: Expected prop `%s` to always be an object.', _key4) : require('fbjs/lib/invariant')(false) : void 0;\n            resolver.setSelector(selector);\n          }\n        }\n\n        this._resolvers[_key4] = resolver;\n      }\n    }\n\n    this._props = props;\n    this._stale = true;\n  };\n\n  RelayModernFragmentSpecResolver.prototype.setVariables = function setVariables(variables) {\n    for (var _key5 in this._resolvers) {\n      if (this._resolvers.hasOwnProperty(_key5)) {\n        var resolver = this._resolvers[_key5];\n\n        if (resolver) {\n          resolver.setVariables(variables);\n        }\n      }\n    }\n\n    this._stale = true;\n  };\n\n  return RelayModernFragmentSpecResolver;\n}();\n/**\n * A resolver for a single Selector.\n */\n\n\nvar SelectorResolver = function () {\n  function SelectorResolver(environment, selector, callback) {\n    (0, _classCallCheck3['default'])(this, SelectorResolver);\n\n    _initialiseProps.call(this);\n\n    var snapshot = environment.lookup(selector);\n    this._callback = callback;\n    this._data = snapshot.data;\n    this._environment = environment;\n    this._selector = selector;\n    this._subscription = environment.subscribe(snapshot, this._onChange);\n  }\n\n  SelectorResolver.prototype.dispose = function dispose() {\n    if (this._subscription) {\n      this._subscription.dispose();\n\n      this._subscription = null;\n    }\n  };\n\n  SelectorResolver.prototype.resolve = function resolve() {\n    return this._data;\n  };\n\n  SelectorResolver.prototype.setSelector = function setSelector(selector) {\n    if (this._subscription != null && require('./RelayModernSelector').areEqualSelectors(selector, this._selector)) {\n      return;\n    }\n\n    this.dispose();\n\n    var snapshot = this._environment.lookup(selector);\n\n    this._data = snapshot.data;\n    this._selector = selector;\n    this._subscription = this._environment.subscribe(snapshot, this._onChange);\n  };\n\n  SelectorResolver.prototype.setVariables = function setVariables(variables) {\n    var selector = (0, _extends3['default'])({}, this._selector, {\n      variables: variables\n    });\n    this.setSelector(selector);\n  };\n\n  SelectorResolver.prototype.isLoading = function isLoading() {\n    return this._environment.isSelectorLoading(this._selector);\n  };\n\n  return SelectorResolver;\n}();\n/**\n * A resolver for an array of Selectors.\n */\n\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this3 = this;\n\n  this._onChange = function (snapshot) {\n    _this3._data = snapshot.data;\n\n    _this3._callback();\n  };\n};\n\nvar SelectorListResolver = function () {\n  function SelectorListResolver(environment, selectors, callback) {\n    var _this2 = this;\n\n    (0, _classCallCheck3['default'])(this, SelectorListResolver);\n\n    this._onChange = function (data) {\n      _this2._stale = true;\n\n      _this2._callback();\n    };\n\n    this._callback = callback;\n    this._data = [];\n    this._environment = environment;\n    this._resolvers = [];\n    this._stale = true;\n    this.setSelectors(selectors);\n  }\n\n  SelectorListResolver.prototype.dispose = function dispose() {\n    this._resolvers.forEach(disposeCallback);\n  };\n\n  SelectorListResolver.prototype.resolve = function resolve() {\n    if (this._stale) {\n      // Avoid mapping the array multiple times, which could occur if data for\n      // multiple indices changes in the same event loop.\n      var prevData = this._data;\n      var nextData = void 0;\n\n      for (var ii = 0; ii < this._resolvers.length; ii++) {\n        var prevItem = prevData[ii];\n\n        var nextItem = this._resolvers[ii].resolve();\n\n        if (nextData || nextItem !== prevItem) {\n          nextData = nextData || prevData.slice(0, ii);\n          nextData.push(nextItem);\n        }\n      }\n\n      if (!nextData && this._resolvers.length !== prevData.length) {\n        nextData = prevData.slice(0, this._resolvers.length);\n      }\n\n      this._data = nextData || prevData;\n      this._stale = false;\n    }\n\n    return this._data;\n  };\n\n  SelectorListResolver.prototype.setSelectors = function setSelectors(selectors) {\n    while (this._resolvers.length > selectors.length) {\n      var resolver = this._resolvers.pop();\n\n      resolver.dispose();\n    }\n\n    for (var ii = 0; ii < selectors.length; ii++) {\n      if (ii < this._resolvers.length) {\n        this._resolvers[ii].setSelector(selectors[ii]);\n      } else {\n        this._resolvers[ii] = new SelectorResolver(this._environment, selectors[ii], this._onChange);\n      }\n    }\n\n    this._stale = true;\n  };\n\n  SelectorListResolver.prototype.setVariables = function setVariables(variables) {\n    this._resolvers.forEach(function (resolver) {\n      return resolver.setVariables(variables);\n    });\n\n    this._stale = true;\n  };\n\n  SelectorListResolver.prototype.isLoading = function isLoading() {\n    return this._resolvers.some(function (resolver) {\n      return resolver.isLoading();\n    });\n  };\n\n  return SelectorListResolver;\n}();\n\nfunction disposeCallback(disposable) {\n  disposable && disposable.dispose();\n}\n\nmodule.exports = RelayModernFragmentSpecResolver;","map":null,"metadata":{},"sourceType":"script"}