{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nvar _objectWithoutProperties3 = _interopRequireDefault(require('babel-runtime/helpers/objectWithoutProperties'));\n\nvar _classCallCheck3 = _interopRequireDefault(require('babel-runtime/helpers/classCallCheck'));\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(require('babel-runtime/helpers/possibleConstructorReturn'));\n\nvar _inherits3 = _interopRequireDefault(require('babel-runtime/helpers/inherits'));\n\nvar _defineProperty3 = _interopRequireDefault(require('babel-runtime/helpers/defineProperty'));\n\nvar _extends4 = _interopRequireDefault(require('babel-runtime/helpers/extends'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar containerContextTypes = {\n  relay: require('./RelayPropTypes').Relay\n};\nvar FORWARD = 'forward';\n/**\n * Extends the functionality of RelayFragmentContainer by providing a mechanism\n * to load more data from a connection.\n *\n * # Configuring a PaginationContainer\n *\n * PaginationContainer accepts the standard FragmentContainer arguments and an\n * additional `connectionConfig` argument:\n *\n * - `Component`: the component to be wrapped/rendered.\n * - `fragments`: an object whose values are `graphql` fragments. The object\n *   keys determine the prop names by which fragment data is available.\n * - `connectionConfig`: an object that determines how to load more connection\n *   data. Details below.\n *\n * # Loading More Data\n *\n * Use `props.relay.hasMore()` to determine if there are more items to load.\n *\n * ```\n * hasMore(): boolean\n * ```\n *\n * Use `props.relay.isLoading()` to determine if a previous call to `loadMore()`\n * is still pending. This is convenient for avoiding duplicate load calls.\n *\n * ```\n * isLoading(): boolean\n * ```\n *\n * Use `props.relay.loadMore()` to load more items. This will return null if\n * there are no more items to fetch, otherwise it will fetch more items and\n * return a Disposable that can be used to cancel the fetch.\n *\n * `pageSize` should be the number of *additional* items to fetch (not the\n * total).\n *\n * ```\n * loadMore(pageSize: number, callback: ?(error: ?Error) => void): ?Disposable\n * ```\n *\n * A complete example:\n *\n * ```\n * class Foo extends React.Component {\n *   ...\n *   _onEndReached() {\n *     if (!this.props.relay.hasMore() || this.props.relay.isLoading()) {\n *       return;\n *     }\n *     this.props.relay.loadMore(10);\n *   }\n *   ...\n * }\n * ```\n *\n * # Connection Config\n *\n * Here's an example, followed by details of each config property:\n *\n * ```\n * ReactRelayPaginationContainer.createContainer(\n *   Component,\n *   {\n *     user: graphql`fragment FriendsFragment on User {\n *       friends(after: $afterCursor first: $count) @connection {\n *         edges { ... }\n *         pageInfo {\n *           startCursor\n *           endCursor\n *           hasNextPage\n *           hasPreviousPage\n *         }\n *       }\n *     }`,\n *   },\n *   {\n *     direction: 'forward',\n *     getConnectionFromProps(props) {\n *       return props.user && props.user.friends;\n *     },\n *     getFragmentVariables(vars, totalCount) {\n *       // The component presumably wants *all* edges, not just those after\n *       // the cursor, so notice that we don't set $afterCursor here.\n *       return {\n *         ...vars,\n *         count: totalCount,\n *       };\n *     },\n *     getVariables(props, {count, cursor}, fragmentVariables) {\n *       return {\n *         id: props.user.id,\n *         afterCursor: cursor,\n *         count,\n *       },\n *     },\n *     query: graphql`\n *       query FriendsQuery($id: ID!, $afterCursor: ID, $count: Int!) {\n *         node(id: $id) {\n *           ...FriendsFragment\n *         }\n *       }\n *     `,\n *   }\n * );\n * ```\n *\n * ## Config Properties\n *\n * - `direction`: Either \"forward\" to indicate forward pagination using\n *   after/first, or \"backward\" to indicate backward pagination using\n *   before/last.\n * - `getConnectionFromProps(props)`: PaginationContainer doesn't magically know\n *   which connection data you mean to fetch more of (a container might fetch\n *   multiple connections, but can only paginate one of them). This function is\n *   given the fragment props only (not full props), and should return the\n *   connection data. See the above example that returns the friends data via\n *   `props.user.friends`.\n * - `getFragmentVariables(previousVars, totalCount)`: Given the previous variables\n *   and the new total number of items, get the variables to use when reading\n *   your fragments. Typically this means setting whatever your local \"count\"\n *   variable is to the value of `totalCount`. See the example.\n * - `getVariables(props, {count, cursor})`: Get the variables to use when\n *   fetching the pagination `query`. You may determine the root object id from\n *   props (see the example that uses `props.user.id`) and may also set whatever\n *   variables you use for the after/first/before/last calls based on the count\n *   and cursor.\n * - `query`: A query to use when fetching more connection data. This should\n *   typically reference one of the container's fragment (as in the example)\n *   to ensure that all the necessary fields for sub-components are fetched.\n */\n\nfunction createGetConnectionFromProps(metadata) {\n  var path = metadata.path;\n  !path ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'ReactRelayPaginationContainer: Unable to synthesize a ' + 'getConnectionFromProps function.') : require('fbjs/lib/invariant')(false) : void 0;\n  return function (props) {\n    var data = props[metadata.fragmentName];\n\n    for (var i = 0; i < path.length; i++) {\n      if (!data || typeof data !== 'object') {\n        return null;\n      }\n\n      data = data[path[i]];\n    }\n\n    return data;\n  };\n}\n\nfunction createGetFragmentVariables(metadata) {\n  var countVariable = metadata.count;\n  !countVariable ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'ReactRelayPaginationContainer: Unable to synthesize a ' + 'getFragmentVariables function.') : require('fbjs/lib/invariant')(false) : void 0;\n  return function (prevVars, totalCount) {\n    return (0, _extends4['default'])({}, prevVars, (0, _defineProperty3['default'])({}, countVariable, totalCount));\n  };\n}\n\nfunction findConnectionMetadata(fragments) {\n  var foundConnectionMetadata = null;\n  var isRelayModern = false;\n\n  for (var _fragmentName in fragments) {\n    var fragment = fragments[_fragmentName];\n    var connectionMetadata = fragment.metadata && fragment.metadata.connection; // HACK: metadata is always set to `undefined` in classic. In modern, even\n    // if empty, it is set to null (never undefined). We use that knowlege to\n    // check if we're dealing with classic or modern\n\n    if (fragment.metadata !== undefined) {\n      isRelayModern = true;\n    }\n\n    if (connectionMetadata) {\n      !(connectionMetadata.length === 1) ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'ReactRelayPaginationContainer: Only a single @connection is ' + 'supported, `%s` has %s.', _fragmentName, connectionMetadata.length) : require('fbjs/lib/invariant')(false) : void 0;\n      !!foundConnectionMetadata ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'ReactRelayPaginationContainer: Only a single fragment with ' + '@connection is supported.') : require('fbjs/lib/invariant')(false) : void 0;\n      foundConnectionMetadata = (0, _extends4['default'])({}, connectionMetadata[0], {\n        fragmentName: _fragmentName\n      });\n    }\n  }\n\n  !(!isRelayModern || foundConnectionMetadata !== null) ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'ReactRelayPaginationContainer: A @connection directive must be present.') : require('fbjs/lib/invariant')(false) : void 0;\n  return foundConnectionMetadata || {};\n}\n\nfunction toObserver(observerOrCallback) {\n  return typeof observerOrCallback === 'function' ? {\n    error: observerOrCallback,\n    complete: observerOrCallback,\n    unsubscribe: function unsubscribe(subscription) {\n      typeof observerOrCallback === 'function' && observerOrCallback();\n    }\n  } : observerOrCallback || {};\n}\n\nfunction createContainerWithFragments(Component, fragments, connectionConfig) {\n  var componentName = require('./ReactRelayContainerUtils').getComponentName(Component);\n\n  var containerName = require('./ReactRelayContainerUtils').getContainerName(Component);\n\n  var metadata = findConnectionMetadata(fragments);\n  var getConnectionFromProps = connectionConfig.getConnectionFromProps || createGetConnectionFromProps(metadata);\n  var direction = connectionConfig.direction || metadata.direction;\n  !direction ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'ReactRelayPaginationContainer: Unable to infer direction of the ' + 'connection, possibly because both first and last are provided.') : require('fbjs/lib/invariant')(false) : void 0;\n  var getFragmentVariables = connectionConfig.getFragmentVariables || createGetFragmentVariables(metadata);\n\n  var Container = function (_React$Component) {\n    (0, _inherits3['default'])(Container, _React$Component);\n\n    function Container(props, context) {\n      (0, _classCallCheck3['default'])(this, Container);\n\n      var _this = (0, _possibleConstructorReturn3['default'])(this, _React$Component.call(this, props, context));\n\n      _this._handleFragmentDataUpdate = function () {\n        var profiler = require('relay-runtime').RelayProfiler.profile('ReactRelayPaginationContainer.handleFragmentDataUpdate');\n\n        _this.setState({\n          data: _this._resolver.resolve()\n        }, profiler.stop);\n      };\n\n      _this._hasMore = function () {\n        var connectionData = _this._getConnectionData();\n\n        return !!(connectionData && connectionData.hasMore && connectionData.cursor);\n      };\n\n      _this._isLoading = function () {\n        return !!_this._refetchSubscription;\n      };\n\n      _this._refetchConnection = function (totalCount, observerOrCallback, refetchVariables) {\n        _this._refetchVariables = refetchVariables;\n        var paginatingVariables = {\n          count: totalCount,\n          cursor: null,\n          totalCount: totalCount\n        };\n\n        var fetch = _this._fetchPage(paginatingVariables, toObserver(observerOrCallback), {\n          force: true\n        });\n\n        return {\n          dispose: fetch.unsubscribe\n        };\n      };\n\n      _this._loadMore = function (pageSize, observerOrCallback, options) {\n        var observer = toObserver(observerOrCallback);\n\n        var connectionData = _this._getConnectionData();\n\n        if (!connectionData) {\n          require('relay-runtime').Observable.create(function (sink) {\n            return sink.complete();\n          }).subscribe(observer);\n\n          return null;\n        }\n\n        var totalCount = connectionData.edgeCount + pageSize;\n\n        if (options && options.force) {\n          return _this._refetchConnection(totalCount, observerOrCallback);\n        }\n\n        var _ConnectionInterface$ = require('relay-runtime').ConnectionInterface.get(),\n            END_CURSOR = _ConnectionInterface$.END_CURSOR,\n            START_CURSOR = _ConnectionInterface$.START_CURSOR;\n\n        var cursor = connectionData.cursor;\n        process.env.NODE_ENV !== 'production' ? require('fbjs/lib/warning')(cursor, 'ReactRelayPaginationContainer: Cannot `loadMore` without valid `%s` (got `%s`)', direction === FORWARD ? END_CURSOR : START_CURSOR, cursor) : void 0;\n        var paginatingVariables = {\n          count: pageSize,\n          cursor: cursor,\n          totalCount: totalCount\n        };\n        _this._hasPaginated = true;\n\n        var fetch = _this._fetchPage(paginatingVariables, observer, options);\n\n        return {\n          dispose: fetch.unsubscribe\n        };\n      };\n\n      var relay = require('./RelayContext').assertRelayContext(context.relay);\n\n      var createFragmentSpecResolver = relay.environment.unstable_internal.createFragmentSpecResolver;\n      _this._isARequestInFlight = false;\n      _this._hasPaginated = false;\n      _this._refetchSubscription = null;\n      _this._refetchVariables = null;\n      _this._resolver = createFragmentSpecResolver(relay, containerName, fragments, props, _this._handleFragmentDataUpdate);\n      _this._relayContext = {\n        environment: relay.environment,\n        variables: relay.variables\n      };\n      _this.state = {\n        data: _this._resolver.resolve(),\n        relayEnvironment: relay.environment,\n        relayProp: _this._buildRelayProp(relay),\n        relayVariables: relay.variables\n      };\n      return _this;\n    }\n    /**\n     * When new props are received, read data for the new props and subscribe\n     * for updates. Props may be the same in which case previous data and\n     * subscriptions can be reused.\n     */\n\n\n    Container.prototype.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps, nextContext) {\n      var context = require('fbjs/lib/nullthrows')(nextContext);\n\n      var relay = require('./RelayContext').assertRelayContext(context.relay);\n\n      var _relay$environment$un = relay.environment.unstable_internal,\n          createFragmentSpecResolver = _relay$environment$un.createFragmentSpecResolver,\n          getDataIDsFromObject = _relay$environment$un.getDataIDsFromObject;\n      var prevIDs = getDataIDsFromObject(fragments, this.props);\n      var nextIDs = getDataIDsFromObject(fragments, nextProps); // If the environment has changed or props point to new records then\n      // previously fetched data and any pending fetches no longer apply:\n      // - Existing references are on the old environment.\n      // - Existing references are based on old variables.\n      // - Pending fetches are for the previous records.\n\n      if (this.state.relayEnvironment !== relay.environment || this.state.relayVariables !== relay.variables || !require('fbjs/lib/areEqual')(prevIDs, nextIDs)) {\n        this._cleanup(); // Child containers rely on context.relay being mutated (for gDSFP).\n\n\n        this._relayContext.environment = relay.environment;\n        this._relayContext.variables = relay.variables;\n        this._resolver = createFragmentSpecResolver(relay, containerName, fragments, nextProps, this._handleFragmentDataUpdate);\n        this.setState({\n          relayEnvironment: relay.environment,\n          relayProp: this._buildRelayProp(relay),\n          relayVariables: relay.variables\n        });\n      } else if (!this._hasPaginated) {\n        this._resolver.setProps(nextProps);\n      }\n\n      var data = this._resolver.resolve();\n\n      if (data !== this.state.data) {\n        this.setState({\n          data: data\n        });\n      }\n    };\n\n    Container.prototype.componentWillUnmount = function componentWillUnmount() {\n      this._cleanup();\n    };\n\n    Container.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n      // Short-circuit if any Relay-related data has changed\n      if (nextState.data !== this.state.data || nextState.relayProp !== this.state.relayProp) {\n        return true;\n      } // Otherwise, for convenience short-circuit if all non-Relay props\n      // are scalar and equal\n\n\n      var keys = Object.keys(nextProps);\n\n      for (var ii = 0; ii < keys.length; ii++) {\n        var _key = keys[ii];\n\n        if (_key === 'relay') {\n          if (nextState.relayEnvironment !== this.state.relayEnvironment || nextState.relayVariables !== this.state.relayVariables) {\n            return true;\n          }\n        } else {\n          if (!fragments.hasOwnProperty(_key) && !require('relay-runtime').isScalarAndEqual(nextProps[_key], this.props[_key])) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    };\n\n    Container.prototype._buildRelayProp = function _buildRelayProp(relay) {\n      return {\n        hasMore: this._hasMore,\n        isLoading: this._isLoading,\n        loadMore: this._loadMore,\n        refetchConnection: this._refetchConnection,\n        environment: relay.environment\n      };\n    };\n    /**\n     * Render new data for the existing props/context.\n     */\n\n\n    Container.prototype._getConnectionData = function _getConnectionData() {\n      // Extract connection data and verify there are more edges to fetch\n      var _props = this.props,\n          _ = _props.componentRef,\n          restProps = (0, _objectWithoutProperties3['default'])(_props, ['componentRef']);\n      var props = (0, _extends4['default'])({}, restProps, this.state.data);\n      var connectionData = getConnectionFromProps(props);\n\n      if (connectionData == null) {\n        return null;\n      }\n\n      var _ConnectionInterface$2 = require('relay-runtime').ConnectionInterface.get(),\n          EDGES = _ConnectionInterface$2.EDGES,\n          PAGE_INFO = _ConnectionInterface$2.PAGE_INFO,\n          HAS_NEXT_PAGE = _ConnectionInterface$2.HAS_NEXT_PAGE,\n          HAS_PREV_PAGE = _ConnectionInterface$2.HAS_PREV_PAGE,\n          END_CURSOR = _ConnectionInterface$2.END_CURSOR,\n          START_CURSOR = _ConnectionInterface$2.START_CURSOR;\n\n      !(typeof connectionData === 'object') ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return `null` or a plain object with %s and %s properties, got `%s`.', componentName, EDGES, PAGE_INFO, connectionData) : require('fbjs/lib/invariant')(false) : void 0;\n      var edges = connectionData[EDGES];\n      var pageInfo = connectionData[PAGE_INFO];\n\n      if (edges == null || pageInfo == null) {\n        return null;\n      }\n\n      !Array.isArray(edges) ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return an object with %s: Array, got `%s`.', componentName, EDGES, edges) : require('fbjs/lib/invariant')(false) : void 0;\n      !(typeof pageInfo === 'object') ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return an object with %s: Object, got `%s`.', componentName, PAGE_INFO, pageInfo) : require('fbjs/lib/invariant')(false) : void 0;\n      var hasMore = direction === FORWARD ? pageInfo[HAS_NEXT_PAGE] : pageInfo[HAS_PREV_PAGE];\n      var cursor = direction === FORWARD ? pageInfo[END_CURSOR] : pageInfo[START_CURSOR];\n\n      if (typeof hasMore !== 'boolean' || edges.length !== 0 && typeof cursor === 'undefined') {\n        process.env.NODE_ENV !== 'production' ? require('fbjs/lib/warning')(false, 'ReactRelayPaginationContainer: Cannot paginate without %s fields in `%s`. ' + 'Be sure to fetch %s (got `%s`) and %s (got `%s`).', PAGE_INFO, componentName, direction === FORWARD ? HAS_NEXT_PAGE : HAS_PREV_PAGE, hasMore, direction === FORWARD ? END_CURSOR : START_CURSOR, cursor) : void 0;\n        return null;\n      }\n\n      return {\n        cursor: cursor,\n        edgeCount: edges.length,\n        hasMore: hasMore\n      };\n    };\n\n    Container.prototype._getQueryFetcher = function _getQueryFetcher() {\n      if (!this._queryFetcher) {\n        this._queryFetcher = new (require('./ReactRelayQueryFetcher'))();\n      }\n\n      return this._queryFetcher;\n    };\n\n    Container.prototype._fetchPage = function _fetchPage(paginatingVariables, observer, options) {\n      var _this2 = this;\n\n      var _assertRelayContext = require('./RelayContext').assertRelayContext(this.context.relay),\n          environment = _assertRelayContext.environment;\n\n      var _environment$unstable = environment.unstable_internal,\n          createOperationSelector = _environment$unstable.createOperationSelector,\n          getRequest = _environment$unstable.getRequest,\n          getVariablesFromObject = _environment$unstable.getVariablesFromObject;\n      var _props2 = this.props,\n          _ = _props2.componentRef,\n          restProps = (0, _objectWithoutProperties3['default'])(_props2, ['componentRef']);\n      var props = (0, _extends4['default'])({}, restProps, this.state.data);\n      var rootVariables = this._relayContext.variables;\n      var fragmentVariables = getVariablesFromObject(rootVariables, fragments, restProps);\n      fragmentVariables = (0, _extends4['default'])({}, rootVariables, fragmentVariables, this._refetchVariables);\n      var fetchVariables = connectionConfig.getVariables(props, {\n        count: paginatingVariables.count,\n        cursor: paginatingVariables.cursor\n      }, fragmentVariables);\n      !(typeof fetchVariables === 'object' && fetchVariables !== null) ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'ReactRelayPaginationContainer: Expected `getVariables()` to ' + 'return an object, got `%s` in `%s`.', fetchVariables, componentName) : require('fbjs/lib/invariant')(false) : void 0;\n      fetchVariables = (0, _extends4['default'])({}, fetchVariables, this._refetchVariables);\n      var cacheConfig = options ? {\n        force: !!options.force\n      } : undefined;\n\n      if (cacheConfig && options && options.rerunParamExperimental) {\n        cacheConfig.rerunParamExperimental = options.rerunParamExperimental;\n      }\n\n      var request = getRequest(connectionConfig.query);\n      var operation = createOperationSelector(request, fetchVariables);\n      var refetchSubscription = null;\n\n      if (this._refetchSubscription) {\n        this._refetchSubscription.unsubscribe();\n      }\n\n      var onNext = function onNext(payload, complete) {\n        // Child containers rely on context.relay being mutated (for gDSFP).\n        _this2._relayContext.environment = _this2.context.relay.environment;\n        _this2._relayContext.variables = (0, _extends4['default'])({}, _this2.context.relay.variables, fragmentVariables);\n\n        var prevData = _this2._resolver.resolve();\n\n        _this2._resolver.setVariables(getFragmentVariables(fragmentVariables, paginatingVariables.totalCount));\n\n        var nextData = _this2._resolver.resolve(); // Workaround slightly different handling for connection in different\n        // core implementations:\n        // - Classic core requires the count to be explicitly incremented\n        // - Modern core automatically appends new items, updating the count\n        //   isn't required to see new data.\n        //\n        // `setState` is only required if changing the variables would change the\n        // resolved data.\n        // TODO #14894725: remove PaginationContainer equal check\n\n\n        if (!require('fbjs/lib/areEqual')(prevData, nextData)) {\n          _this2.setState({\n            data: nextData\n          }, complete);\n        } else {\n          complete();\n        }\n      };\n\n      var cleanup = function cleanup() {\n        if (_this2._refetchSubscription === refetchSubscription) {\n          _this2._refetchSubscription = null;\n          _this2._isARequestInFlight = false;\n        }\n      };\n\n      this._isARequestInFlight = true;\n      refetchSubscription = this._getQueryFetcher().execute({\n        environment: environment,\n        operation: operation,\n        cacheConfig: cacheConfig,\n        preservePreviousReferences: true\n      }).mergeMap(function (payload) {\n        return require('relay-runtime').Observable.create(function (sink) {\n          onNext(payload, function () {\n            sink.next(); // pass void to public observer's `next`\n\n            sink.complete();\n          });\n        });\n      }) // use do instead of finally so that observer's `complete` fires after cleanup\n      ['do']({\n        error: cleanup,\n        complete: cleanup,\n        unsubscribe: cleanup\n      }).subscribe(observer || {});\n      this._refetchSubscription = this._isARequestInFlight ? refetchSubscription : null;\n      return refetchSubscription;\n    };\n\n    Container.prototype._cleanup = function _cleanup() {\n      this._resolver.dispose();\n\n      this._hasPaginated = false;\n      this._refetchVariables = null;\n\n      if (this._refetchSubscription) {\n        this._refetchSubscription.unsubscribe();\n\n        this._refetchSubscription = null;\n        this._isARequestInFlight = false;\n      }\n\n      if (this._queryFetcher) {\n        this._queryFetcher.dispose();\n      }\n    };\n\n    Container.prototype.getChildContext = function getChildContext() {\n      return {\n        relay: this._relayContext\n      };\n    };\n\n    Container.prototype.render = function render() {\n      var _props3 = this.props,\n          componentRef = _props3.componentRef,\n          props = (0, _objectWithoutProperties3['default'])(_props3, ['componentRef']);\n      return require('react').createElement(Component, (0, _extends4['default'])({}, props, this.state.data, {\n        ref: componentRef,\n        relay: this.state.relayProp\n      }));\n    };\n\n    return Container;\n  }(require('react').Component);\n\n  Container.displayName = containerName;\n  Container.contextTypes = containerContextTypes;\n\n  require('./ReactRelayContainerProfiler').profileContainer(Container, 'ReactRelayPaginationContainer');\n\n  return Container;\n}\n/**\n * Wrap the basic `createContainer()` function with logic to adapt to the\n * `context.relay.environment` in which it is rendered. Specifically, the\n * extraction of the environment-specific version of fragments in the\n * `fragmentSpec` is memoized once per environment, rather than once per\n * instance of the container constructed/rendered.\n */\n\n\nfunction createContainer(Component, fragmentSpec, connectionConfig) {\n  return require('./buildReactRelayContainer')(Component, fragmentSpec, function (ComponentClass, fragments) {\n    return createContainerWithFragments(ComponentClass, fragments, connectionConfig);\n  },\n  /* provides child context */\n  true);\n}\n\nmodule.exports = {\n  createContainer: createContainer,\n  createContainerWithFragments: createContainerWithFragments\n};","map":null,"metadata":{},"sourceType":"script"}