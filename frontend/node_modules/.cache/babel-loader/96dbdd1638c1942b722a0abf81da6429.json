{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict-local\n * @format\n */\n'use strict';\n\nvar _classCallCheck3 = _interopRequireDefault(require('babel-runtime/helpers/classCallCheck'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar ReactRelayQueryFetcher = function () {\n  function ReactRelayQueryFetcher() {\n    (0, _classCallCheck3['default'])(this, ReactRelayQueryFetcher);\n    this._selectionReferences = [];\n    this._callOnDataChangeWhenSet = false;\n  } // results of the root fragment;\n  // fetch error\n\n\n  ReactRelayQueryFetcher.prototype.lookupInStore = function lookupInStore(environment, operation) {\n    if (environment.check(operation.root)) {\n      this._retainCachedOperation(environment, operation);\n\n      return environment.lookup(operation.fragment);\n    }\n\n    return null;\n  };\n\n  ReactRelayQueryFetcher.prototype.execute = function execute(_ref) {\n    var _this = this;\n\n    var environment = _ref.environment,\n        operation = _ref.operation,\n        cacheConfig = _ref.cacheConfig,\n        _ref$preservePrevious = _ref.preservePreviousReferences,\n        preservePreviousReferences = _ref$preservePrevious === undefined ? false : _ref$preservePrevious;\n    var createOperationSelector = environment.unstable_internal.createOperationSelector;\n    var nextReferences = [];\n    return environment.execute({\n      operation: operation,\n      cacheConfig: cacheConfig\n    }).map(function (payload) {\n      var operationForPayload = createOperationSelector(operation.node, payload.variables, payload.operation);\n      nextReferences.push(environment.retain(operationForPayload.root));\n      return payload;\n    })['do']({\n      error: function error() {\n        // We may have partially fulfilled the request, so let the next request\n        // or the unmount dispose of the references.\n        _this._selectionReferences = _this._selectionReferences.concat(nextReferences);\n      },\n      complete: function complete() {\n        if (!preservePreviousReferences) {\n          _this._disposeSelectionReferences();\n        }\n\n        _this._selectionReferences = _this._selectionReferences.concat(nextReferences);\n      },\n      unsubscribe: function unsubscribe() {\n        // Let the next request or the unmount code dispose of the references.\n        // We may have partially fulfilled the request.\n        _this._selectionReferences = _this._selectionReferences.concat(nextReferences);\n      }\n    });\n  };\n\n  ReactRelayQueryFetcher.prototype.setOnDataChange = function setOnDataChange(onDataChange) {\n    !this._fetchOptions ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'ReactRelayQueryFetcher: `setOnDataChange` should have been called after having called `fetch`') : require('fbjs/lib/invariant')(false) : void 0; // Mutate the most recent fetchOptions in place,\n    // So that in-progress requests can access the updated callback.\n\n    this._fetchOptions.onDataChange = onDataChange;\n\n    if (this._callOnDataChangeWhenSet && typeof onDataChange === 'function') {\n      this._callOnDataChangeWhenSet = false;\n\n      if (this._error != null) {\n        onDataChange({\n          error: this._error\n        });\n      } else if (this._snapshot != null) {\n        onDataChange({\n          snapshot: this._snapshot\n        });\n      }\n    }\n  };\n  /**\n   * `fetch` fetches the data for the given operation.\n   * If a result is immediately available synchronously, it will be synchronously\n   * returned by this function.\n   *\n   * Otherwise, the fetched result will be communicated via the `onDataChange` callback.\n   * `onDataChange` will be called with the first result (**if it wasn't returned synchronously**),\n   * and then subsequently whenever the data changes.\n   */\n\n\n  ReactRelayQueryFetcher.prototype.fetch = function fetch(fetchOptions) {\n    var _this2 = this;\n\n    var cacheConfig = fetchOptions.cacheConfig,\n        environment = fetchOptions.environment,\n        operation = fetchOptions.operation;\n    var fetchHasReturned = false;\n    var error = void 0;\n\n    this._disposeRequest();\n\n    this._fetchOptions = fetchOptions;\n    var request = this.execute({\n      environment: environment,\n      operation: operation,\n      cacheConfig: cacheConfig\n    })['finally'](function () {\n      _this2._pendingRequest = null;\n    }).subscribe({\n      next: function next() {\n        var onDataChange = _this2._fetchOptions ? _this2._fetchOptions.onDataChange : null; // If we received a response when we didn't have a change callback,\n        // Make a note that to notify the callback when it's later added.\n\n        _this2._callOnDataChangeWhenSet = typeof onDataChange !== 'function';\n        _this2._error = null; // Only notify of the first result if `next` is being called **asynchronously**\n        // (i.e. after `fetch` has returned).\n\n        _this2._onQueryDataAvailable({\n          notifyFirstResult: fetchHasReturned\n        });\n      },\n      error: function (_error) {\n        function error(_x) {\n          return _error.apply(this, arguments);\n        }\n\n        error.toString = function () {\n          return _error.toString();\n        };\n\n        return error;\n      }(function (err) {\n        var onDataChange = _this2._fetchOptions ? _this2._fetchOptions.onDataChange : null; // If we received a response when we didn't have a change callback,\n        // Make a note that to notify the callback when it's later added.\n\n        _this2._callOnDataChangeWhenSet = typeof onDataChange !== 'function';\n        _this2._error = err;\n        _this2._snapshot = null; // Only notify of error if `error` is being called **asynchronously**\n        // (i.e. after `fetch` has returned).\n\n        if (fetchHasReturned) {\n          if (typeof onDataChange === 'function') {\n            onDataChange({\n              error: err\n            });\n          }\n        } else {\n          error = err;\n        }\n      })\n    });\n    this._pendingRequest = {\n      dispose: function dispose() {\n        request.unsubscribe();\n      }\n    };\n    fetchHasReturned = true;\n\n    if (error) {\n      throw error;\n    }\n\n    return this._snapshot;\n  };\n\n  ReactRelayQueryFetcher.prototype.retry = function retry() {\n    !this._fetchOptions ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'ReactRelayQueryFetcher: `retry` should be called after having called `fetch`') : require('fbjs/lib/invariant')(false) : void 0;\n    return this.fetch(this._fetchOptions);\n  };\n\n  ReactRelayQueryFetcher.prototype.dispose = function dispose() {\n    this._disposeRequest();\n\n    this._disposeSelectionReferences();\n  };\n\n  ReactRelayQueryFetcher.prototype._disposeRequest = function _disposeRequest() {\n    this._error = null;\n    this._snapshot = null; // order is important, dispose of pendingFetch before selectionReferences\n\n    if (this._pendingRequest) {\n      this._pendingRequest.dispose();\n    }\n\n    if (this._rootSubscription) {\n      this._rootSubscription.dispose();\n\n      this._rootSubscription = null;\n    }\n  };\n\n  ReactRelayQueryFetcher.prototype._retainCachedOperation = function _retainCachedOperation(environment, operation) {\n    this._disposeCacheSelectionReference();\n\n    this._cacheSelectionReference = environment.retain(operation.root);\n  };\n\n  ReactRelayQueryFetcher.prototype._disposeCacheSelectionReference = function _disposeCacheSelectionReference() {\n    this._cacheSelectionReference && this._cacheSelectionReference.dispose();\n    this._cacheSelectionReference = null;\n  };\n\n  ReactRelayQueryFetcher.prototype._disposeSelectionReferences = function _disposeSelectionReferences() {\n    this._disposeCacheSelectionReference();\n\n    this._selectionReferences.forEach(function (r) {\n      return r.dispose();\n    });\n\n    this._selectionReferences = [];\n  };\n\n  ReactRelayQueryFetcher.prototype._onQueryDataAvailable = function _onQueryDataAvailable(_ref2) {\n    var _this3 = this;\n\n    var notifyFirstResult = _ref2.notifyFirstResult;\n    !this._fetchOptions ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'ReactRelayQueryFetcher: `_onQueryDataAvailable` should have been called after having called `fetch`') : require('fbjs/lib/invariant')(false) : void 0;\n    var _fetchOptions = this._fetchOptions,\n        environment = _fetchOptions.environment,\n        onDataChange = _fetchOptions.onDataChange,\n        operation = _fetchOptions.operation; // `_onQueryDataAvailable` can be called synchronously the first time and can be called\n    // multiple times by network layers that support data subscriptions.\n    // Wait until the first payload to call `onDataChange` and subscribe for data updates.\n\n    if (this._snapshot) {\n      return;\n    }\n\n    this._snapshot = environment.lookup(operation.fragment); // Subscribe to changes in the data of the root fragment\n\n    this._rootSubscription = environment.subscribe(this._snapshot, function (snapshot) {\n      // Read from this._fetchOptions in case onDataChange() was lazily added.\n      if (_this3._fetchOptions != null) {\n        var maybeNewOnDataChange = _this3._fetchOptions.onDataChange;\n\n        if (typeof maybeNewOnDataChange === 'function') {\n          maybeNewOnDataChange({\n            snapshot: snapshot\n          });\n        }\n      }\n    });\n\n    if (this._snapshot && notifyFirstResult && typeof onDataChange === 'function') {\n      onDataChange({\n        snapshot: this._snapshot\n      });\n    }\n  };\n\n  return ReactRelayQueryFetcher;\n}();\n\nmodule.exports = ReactRelayQueryFetcher;","map":null,"metadata":{},"sourceType":"script"}