{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nvar _classCallCheck3 = _interopRequireDefault(require('babel-runtime/helpers/classCallCheck'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n/**\n * A Subscription object is returned from .subscribe(), which can be\n * unsubscribed or checked to see if the resulting subscription has closed.\n */\n\n/**\n * An Observer is an object of optional callback functions provided to\n * .subscribe(). Each callback function is invoked when that event occurs.\n */\n\n/**\n * A Sink is an object of methods provided by Observable during construction.\n * The methods are to be called to trigger each event. It also contains a closed\n * field to see if the resulting subscription has closed.\n */\n\n/**\n * A Source is the required argument when constructing a new Observable. Similar\n * to a Promise constructor, this is a function which is invoked with a Sink,\n * and may return either a cleanup function or a Subscription instance (for use\n * when composing Observables).\n */\n\n/**\n * A Subscribable is an interface describing any object which can be subscribed.\n *\n * Note: A sink may be passed directly to .subscribe() as its observer,\n * allowing for easily composing Subscribables.\n */\n// Note: This should accept Subscribable<T> instead of RelayObservable<T>,\n// however Flow cannot yet distinguish it from T.\n\n\nvar hostReportError = swallowError;\n/**\n * Limited implementation of ESObservable, providing the limited set of behavior\n * Relay networking requires.\n *\n * Observables retain the benefit of callbacks which can be called\n * synchronously, avoiding any UI jitter, while providing a compositional API,\n * which simplifies logic and prevents mishandling of errors compared to\n * the direct use of callback functions.\n *\n * ESObservable: https://github.com/tc39/proposal-observable\n */\n\nvar RelayObservable = function () {\n  RelayObservable.create = function create(source) {\n    return new RelayObservable(source);\n  }; // Use RelayObservable.create()\n\n\n  function RelayObservable(source) {\n    (0, _classCallCheck3['default'])(this, RelayObservable);\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Early runtime errors for ill-formed sources.\n      if (!source || typeof source !== 'function') {\n        throw new Error('Source must be a Function: ' + String(source));\n      }\n    }\n\n    this._source = source;\n  }\n  /**\n   * When an emitted error event is not handled by an Observer, it is reported\n   * to the host environment (what the ESObservable spec refers to as\n   * \"HostReportErrors()\").\n   *\n   * The default implementation in development rethrows thrown errors, and\n   * logs emitted error events to the console, while in production does nothing\n   * (swallowing unhandled errors).\n   *\n   * Called during application initialization, this method allows\n   * application-specific handling of unhandled errors. Allowing, for example,\n   * integration with error logging or developer tools.\n   *\n   * A second parameter `isUncaughtThrownError` is true when the unhandled error\n   * was thrown within an Observer handler, and false when the unhandled error\n   * was an unhandled emitted event.\n   *\n   *  - Uncaught thrown errors typically represent avoidable errors thrown from\n   *    application code, which should be handled with a try/catch block, and\n   *    usually have useful stack traces.\n   *\n   *  - Unhandled emitted event errors typically represent unavoidable events in\n   *    application flow such as network failure, and may not have useful\n   *    stack traces.\n   */\n\n\n  RelayObservable.onUnhandledError = function onUnhandledError(callback) {\n    hostReportError = callback;\n  };\n  /**\n   * Accepts various kinds of data sources, and always returns a RelayObservable\n   * useful for accepting the result of a user-provided FetchFunction.\n   */\n\n\n  RelayObservable.from = function from(obj) {\n    return isObservable(obj) ? fromObservable(obj) : require('./isPromise')(obj) ? fromPromise(obj) : fromValue(obj);\n  };\n  /**\n   * Creates a RelayObservable, given a function which expects a legacy\n   * Relay Observer as the last argument and which returns a Disposable.\n   *\n   * To support migration to Observable, the function may ignore the\n   * legacy Relay observer and directly return an Observable instead.\n   */\n\n\n  RelayObservable.fromLegacy = function fromLegacy(callback) {\n    return RelayObservable.create(function (sink) {\n      var result = callback({\n        onNext: sink.next,\n        onError: sink.error,\n        onCompleted: sink.complete\n      });\n      return isObservable(result) ? result.subscribe(sink) : function () {\n        return result.dispose();\n      };\n    });\n  };\n  /**\n   * Similar to promise.catch(), observable.catch() handles error events, and\n   * provides an alternative observable to use in it's place.\n   *\n   * If the catch handler throws a new error, it will appear as an error event\n   * on the resulting Observable.\n   */\n\n\n  RelayObservable.prototype['catch'] = function _catch(fn) {\n    var _this = this;\n\n    return RelayObservable.create(function (sink) {\n      var subscription = void 0;\n\n      _this.subscribe({\n        start: function start(sub) {\n          subscription = sub;\n        },\n        next: sink.next,\n        complete: sink.complete,\n        error: function (_error2) {\n          function error(_x) {\n            return _error2.apply(this, arguments);\n          }\n\n          error.toString = function () {\n            return _error2.toString();\n          };\n\n          return error;\n        }(function (error) {\n          try {\n            fn(error).subscribe({\n              start: function start(sub) {\n                subscription = sub;\n              },\n              next: sink.next,\n              complete: sink.complete,\n              error: sink.error\n            });\n          } catch (error2) {\n            sink.error(error2, true\n            /* isUncaughtThrownError */\n            );\n          }\n        })\n      });\n\n      return function () {\n        return subscription.unsubscribe();\n      };\n    });\n  };\n  /**\n   * Returns a new Observable which returns the same values as this one, but\n   * modified so that the provided Observer is called to perform a side-effects\n   * for all events emitted by the source.\n   *\n   * Any errors that are thrown in the side-effect Observer are unhandled, and\n   * do not affect the source Observable or its Observer.\n   *\n   * This is useful for when debugging your Observables or performing other\n   * side-effects such as logging or performance monitoring.\n   */\n\n\n  RelayObservable.prototype['do'] = function _do(observer) {\n    var _this2 = this;\n\n    return RelayObservable.create(function (sink) {\n      var both = function both(action) {\n        return function () {\n          try {\n            observer[action] && observer[action].apply(observer, arguments);\n          } catch (error) {\n            hostReportError(error, true\n            /* isUncaughtThrownError */\n            );\n          }\n\n          sink[action] && sink[action].apply(sink, arguments);\n        };\n      };\n\n      return _this2.subscribe({\n        start: both('start'),\n        next: both('next'),\n        error: both('error'),\n        complete: both('complete'),\n        unsubscribe: both('unsubscribe')\n      });\n    });\n  };\n  /**\n   * Returns a new Observable which returns the same values as this one, but\n   * modified so that the finally callback is performed after completion,\n   * whether normal or due to error or unsubscription.\n   *\n   * This is useful for cleanup such as resource finalization.\n   */\n\n\n  RelayObservable.prototype['finally'] = function _finally(fn) {\n    var _this3 = this;\n\n    return RelayObservable.create(function (sink) {\n      var subscription = _this3.subscribe(sink);\n\n      return function () {\n        subscription.unsubscribe();\n        fn();\n      };\n    });\n  };\n  /**\n   * Returns a new Observable which is identical to this one, unless this\n   * Observable completes before yielding any values, in which case the new\n   * Observable will yield the values from the alternate Observable.\n   *\n   * If this Observable does yield values, the alternate is never subscribed to.\n   *\n   * This is useful for scenarios where values may come from multiple sources\n   * which should be tried in order, i.e. from a cache before a network.\n   */\n\n\n  RelayObservable.prototype.ifEmpty = function ifEmpty(alternate) {\n    var _this4 = this;\n\n    return RelayObservable.create(function (sink) {\n      var hasValue = false;\n\n      var current = _this4.subscribe({\n        next: function next(value) {\n          hasValue = true;\n          sink.next(value);\n        },\n        error: sink.error,\n        complete: function complete() {\n          if (hasValue) {\n            sink.complete();\n          } else {\n            current = alternate.subscribe(sink);\n          }\n        }\n      });\n\n      return function () {\n        current.unsubscribe();\n      };\n    });\n  };\n  /**\n   * Observable's primary API: returns an unsubscribable Subscription to the\n   * source of this Observable.\n   *\n   * Note: A sink may be passed directly to .subscribe() as its observer,\n   * allowing for easily composing Observables.\n   */\n\n\n  RelayObservable.prototype.subscribe = function subscribe(observer) {\n    if (process.env.NODE_ENV !== 'production') {\n      // Early runtime errors for ill-formed observers.\n      if (!observer || typeof observer !== 'object') {\n        throw new Error('Observer must be an Object with callbacks: ' + String(observer));\n      }\n    }\n\n    return _subscribe(this._source, observer);\n  };\n  /**\n   * Supports subscription of a legacy Relay Observer, returning a Disposable.\n   */\n\n\n  RelayObservable.prototype.subscribeLegacy = function subscribeLegacy(legacyObserver) {\n    var subscription = this.subscribe({\n      next: legacyObserver.onNext,\n      error: legacyObserver.onError,\n      complete: legacyObserver.onCompleted\n    });\n    return {\n      dispose: subscription.unsubscribe\n    };\n  };\n  /**\n   * Returns a new Observerable where each value has been transformed by\n   * the mapping function.\n   */\n\n\n  RelayObservable.prototype.map = function map(fn) {\n    return this.mergeMap(function (value) {\n      return fromValue(fn(value));\n    });\n  };\n  /**\n   * Returns a new Observable where each value is replaced with a new Observable\n   * by the mapping function, the results of which returned as a single\n   * merged Observable.\n   */\n\n\n  RelayObservable.prototype.mergeMap = function mergeMap(fn) {\n    var _this5 = this;\n\n    return RelayObservable.create(function (sink) {\n      var subscriptions = [];\n\n      function start(subscription) {\n        this._sub = subscription;\n        subscriptions.push(subscription);\n      }\n\n      function complete() {\n        subscriptions.splice(subscriptions.indexOf(this._sub), 1);\n\n        if (subscriptions.length === 0) {\n          sink.complete();\n        }\n      }\n\n      _this5.subscribe({\n        start: start,\n        next: function next(value) {\n          try {\n            if (!sink.closed) {\n              RelayObservable.from(fn(value)).subscribe({\n                start: start,\n                next: sink.next,\n                error: sink.error,\n                complete: complete\n              });\n            }\n          } catch (error) {\n            sink.error(error, true\n            /* isUncaughtThrownError */\n            );\n          }\n        },\n        error: sink.error,\n        complete: complete\n      });\n\n      return function () {\n        subscriptions.forEach(function (sub) {\n          return sub.unsubscribe();\n        });\n        subscriptions.length = 0;\n      };\n    });\n  };\n  /**\n   * Returns a new Observable which first mirrors this Observable, then when it\n   * completes, waits for `pollInterval` milliseconds before re-subscribing to\n   * this Observable again, looping in this manner until unsubscribed.\n   *\n   * The returned Observable never completes.\n   */\n\n\n  RelayObservable.prototype.poll = function poll(pollInterval) {\n    var _this6 = this;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof pollInterval !== 'number' || pollInterval <= 0) {\n        throw new Error('RelayObservable: Expected pollInterval to be positive, got: ' + pollInterval);\n      }\n    }\n\n    return RelayObservable.create(function (sink) {\n      var subscription = void 0;\n      var timeout = void 0;\n\n      var poll = function poll() {\n        subscription = _this6.subscribe({\n          next: sink.next,\n          error: sink.error,\n          complete: function complete() {\n            timeout = setTimeout(poll, pollInterval);\n          }\n        });\n      };\n\n      poll();\n      return function () {\n        clearTimeout(timeout);\n        subscription.unsubscribe();\n      };\n    });\n  };\n  /**\n   * Returns a Promise which resolves when this Observable yields a first value\n   * or when it completes with no value.\n   */\n\n\n  RelayObservable.prototype.toPromise = function toPromise() {\n    var _this7 = this;\n\n    return new Promise(function (resolve, reject) {\n      var subscription = void 0;\n\n      _this7.subscribe({\n        start: function start(sub) {\n          subscription = sub;\n        },\n        next: function next(val) {\n          resolve(val);\n          subscription.unsubscribe();\n        },\n        error: reject,\n        complete: resolve\n      });\n    });\n  };\n\n  return RelayObservable;\n}(); // Use declarations to teach Flow how to check isObservable.\n\n\nfunction isObservable(obj) {\n  return typeof obj === 'object' && obj !== null && typeof obj.subscribe === 'function';\n}\n\nfunction fromObservable(obj) {\n  return obj instanceof RelayObservable ? obj : RelayObservable.create(function (sink) {\n    return obj.subscribe(sink);\n  });\n}\n\nfunction fromPromise(promise) {\n  return RelayObservable.create(function (sink) {\n    // Since sink methods do not throw, the resulting Promise can be ignored.\n    promise.then(function (value) {\n      sink.next(value);\n      sink.complete();\n    }, sink.error);\n  });\n}\n\nfunction fromValue(value) {\n  return RelayObservable.create(function (sink) {\n    sink.next(value);\n    sink.complete();\n  });\n}\n\nfunction _subscribe(source, observer) {\n  var closed = false;\n  var cleanup = void 0; // Ideally we would simply describe a `get closed()` method on the Sink and\n  // Subscription objects below, however not all flow environments we expect\n  // Relay to be used within will support property getters, and many minifier\n  // tools still do not support ES5 syntax. Instead, we can use defineProperty.\n\n  var withClosed = function withClosed(obj) {\n    return Object.defineProperty(obj, 'closed', {\n      get: function get() {\n        return closed;\n      }\n    });\n  };\n\n  function doCleanup() {\n    if (cleanup) {\n      if (cleanup.unsubscribe) {\n        cleanup.unsubscribe();\n      } else {\n        try {\n          cleanup();\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        }\n      }\n\n      cleanup = undefined;\n    }\n  } // Create a Subscription.\n\n\n  var subscription = withClosed({\n    unsubscribe: function unsubscribe() {\n      if (!closed) {\n        closed = true; // Tell Observer that unsubscribe was called.\n\n        try {\n          observer.unsubscribe && observer.unsubscribe(subscription);\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        } finally {\n          doCleanup();\n        }\n      }\n    }\n  }); // Tell Observer that observation is about to begin.\n\n  try {\n    observer.start && observer.start(subscription);\n  } catch (error) {\n    hostReportError(error, true\n    /* isUncaughtThrownError */\n    );\n  } // If closed already, don't bother creating a Sink.\n\n\n  if (closed) {\n    return subscription;\n  } // Create a Sink respecting subscription state and cleanup.\n\n\n  var sink = withClosed({\n    next: function next(value) {\n      if (!closed && observer.next) {\n        try {\n          observer.next(value);\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        }\n      }\n    },\n    error: function (_error3) {\n      function error(_x2, _x3) {\n        return _error3.apply(this, arguments);\n      }\n\n      error.toString = function () {\n        return _error3.toString();\n      };\n\n      return error;\n    }(function (error, isUncaughtThrownError) {\n      if (closed || !observer.error) {\n        closed = true;\n        hostReportError(error, isUncaughtThrownError || false);\n        doCleanup();\n      } else {\n        closed = true;\n\n        try {\n          observer.error(error);\n        } catch (error2) {\n          hostReportError(error2, true\n          /* isUncaughtThrownError */\n          );\n        } finally {\n          doCleanup();\n        }\n      }\n    }),\n    complete: function complete() {\n      if (!closed) {\n        closed = true;\n\n        try {\n          observer.complete && observer.complete();\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        } finally {\n          doCleanup();\n        }\n      }\n    }\n  }); // If anything goes wrong during observing the source, handle the error.\n\n  try {\n    cleanup = source(sink);\n  } catch (error) {\n    sink.error(error, true\n    /* isUncaughtThrownError */\n    );\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    // Early runtime errors for ill-formed returned cleanup.\n    if (cleanup !== undefined && typeof cleanup !== 'function' && (!cleanup || typeof cleanup.unsubscribe !== 'function')) {\n      throw new Error('Returned cleanup function which cannot be called: ' + String(cleanup));\n    }\n  } // If closed before the source function existed, cleanup now.\n\n\n  if (closed) {\n    doCleanup();\n  }\n\n  return subscription;\n}\n\nfunction swallowError(_error, _isUncaughtThrownError) {// do nothing.\n}\n\nif (process.env.NODE_ENV !== 'production') {\n  // Default implementation of HostReportErrors() in development builds.\n  // Can be replaced by the host application environment.\n  RelayObservable.onUnhandledError(function (error, isUncaughtThrownError) {\n    if (typeof fail === 'function') {\n      // In test environments (Jest), fail() immediately fails the current test.\n      fail(String(error));\n    } else if (isUncaughtThrownError) {\n      // Rethrow uncaught thrown errors on the next frame to avoid breaking\n      // current logic.\n      setTimeout(function () {\n        throw error;\n      });\n    } else if (typeof console !== 'undefined') {\n      // Otherwise, log the unhandled error for visibility.\n      // eslint-disable-next-line no-console\n      console.error('RelayObservable: Unhandled Error', error);\n    }\n  });\n}\n\nmodule.exports = RelayObservable;","map":null,"metadata":{},"sourceType":"script"}