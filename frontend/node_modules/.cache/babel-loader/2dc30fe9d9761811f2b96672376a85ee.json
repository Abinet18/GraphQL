{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict-local\n * @format\n */\n'use strict';\n\nvar _extends3 = _interopRequireDefault(require('babel-runtime/helpers/extends'));\n\nvar _objectWithoutProperties3 = _interopRequireDefault(require('babel-runtime/helpers/objectWithoutProperties'));\n\nvar _classCallCheck3 = _interopRequireDefault(require('babel-runtime/helpers/classCallCheck'));\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(require('babel-runtime/helpers/possibleConstructorReturn'));\n\nvar _inherits3 = _interopRequireDefault(require('babel-runtime/helpers/inherits'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n/**\n * Composes a React component class, returning a new class that intercepts\n * props, resolving them with the provided fragments and subscribing for\n * updates.\n */\n\n\nfunction createContainerWithFragments(Component, fragments) {\n  var containerName = require('./ReactRelayContainerUtils').getContainerName(Component);\n\n  var Container = function (_React$Component) {\n    (0, _inherits3['default'])(Container, _React$Component);\n\n    function Container(props, context) {\n      (0, _classCallCheck3['default'])(this, Container);\n\n      var _this = (0, _possibleConstructorReturn3['default'])(this, _React$Component.call(this, props, context));\n\n      _this._handleFragmentDataUpdate = function () {\n        var profiler = require('relay-runtime').RelayProfiler.profile('ReactRelayFragmentContainer.handleFragmentDataUpdate');\n\n        var resolverFromThisUpdate = _this.state.resolver;\n\n        _this.setState(function (updatedState) {\n          // If this event belongs to the current data source, update.\n          // Otherwise we should ignore it.\n          if (resolverFromThisUpdate === updatedState.resolver) {\n            return {\n              data: updatedState.resolver.resolve(),\n              relayProp: {\n                isLoading: updatedState.resolver.isLoading(),\n                environment: updatedState.relayProp.environment\n              }\n            };\n          }\n\n          return null;\n        }, profiler.stop);\n      };\n\n      var relay = require('./RelayContext').assertRelayContext(context.relay);\n\n      var createFragmentSpecResolver = relay.environment.unstable_internal.createFragmentSpecResolver; // Do not provide a subscription/callback here.\n      // It is possible for this render to be interrupted or aborted,\n      // In which case the subscription would cause a leak.\n      // We will add the subscription in componentDidMount().\n\n      var resolver = createFragmentSpecResolver(relay, containerName, fragments, props);\n      _this.state = {\n        data: resolver.resolve(),\n        relay: relay,\n        relayEnvironment: context.relay.environment,\n        prevProps: _this.props,\n        relayVariables: context.relay.variables,\n        relayProp: {\n          isLoading: resolver.isLoading(),\n          environment: relay.environment\n        },\n        resolver: resolver\n      };\n      return _this;\n    }\n    /**\n     * When new props are received, read data for the new props and subscribe\n     * for updates. Props may be the same in which case previous data and\n     * subscriptions can be reused.\n     */\n\n\n    Container.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      // Any props change could impact the query, so we mirror props in state.\n      // This is an unusual pattern, but necessary for this container usecase.\n      var prevProps = prevState.prevProps,\n          relay = prevState.relay;\n      var _relay$environment$un = relay.environment.unstable_internal,\n          createFragmentSpecResolver = _relay$environment$un.createFragmentSpecResolver,\n          getDataIDsFromObject = _relay$environment$un.getDataIDsFromObject;\n      var prevIDs = getDataIDsFromObject(fragments, prevProps);\n      var nextIDs = getDataIDsFromObject(fragments, nextProps);\n      var resolver = prevState.resolver; // If the environment has changed or props point to new records then\n      // previously fetched data and any pending fetches no longer apply:\n      // - Existing references are on the old environment.\n      // - Existing references are based on old variables.\n      // - Pending fetches are for the previous records.\n\n      if (prevState.relayEnvironment !== relay.environment || prevState.relayVariables !== relay.variables || !require('fbjs/lib/areEqual')(prevIDs, nextIDs)) {\n        // Do not provide a subscription/callback here.\n        // It is possible for this render to be interrupted or aborted,\n        // In which case the subscription would cause a leak.\n        // We will add the subscription in componentDidUpdate().\n        resolver = createFragmentSpecResolver(relay, containerName, fragments, nextProps);\n        return {\n          data: resolver.resolve(),\n          relayEnvironment: relay.environment,\n          prevProps: nextProps,\n          relayVariables: relay.variables,\n          relayProp: {\n            isLoading: resolver.isLoading(),\n            environment: relay.environment\n          },\n          resolver: resolver\n        };\n      } else {\n        resolver.setProps(nextProps);\n\n        var _data = resolver.resolve();\n\n        if (_data !== prevState.data) {\n          return {\n            data: _data,\n            relayEnvironment: relay.environment,\n            prevProps: nextProps,\n            relayVariables: relay.variables,\n            relayProp: {\n              isLoading: resolver.isLoading(),\n              environment: relay.environment\n            }\n          };\n        }\n      }\n\n      return null;\n    };\n\n    Container.prototype.componentDidMount = function componentDidMount() {\n      this._subscribeToNewResolver();\n\n      this._rerenderIfStoreHasChanged();\n    };\n\n    Container.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n      if (this.state.resolver !== prevState.resolver) {\n        prevState.resolver.dispose();\n\n        this._subscribeToNewResolver();\n      }\n\n      this._rerenderIfStoreHasChanged();\n    };\n\n    Container.prototype.componentWillUnmount = function componentWillUnmount() {\n      this.state.resolver.dispose();\n    };\n\n    Container.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n      // Short-circuit if any Relay-related data has changed\n      if (nextState.data !== this.state.data) {\n        return true;\n      } // Otherwise, for convenience short-circuit if all non-Relay props\n      // are scalar and equal\n\n\n      var keys = Object.keys(nextProps);\n\n      for (var ii = 0; ii < keys.length; ii++) {\n        var _key = keys[ii];\n\n        if (_key === 'relay') {\n          if (nextState.relayEnvironment !== this.state.relayEnvironment || nextState.relayVariables !== this.state.relayVariables) {\n            return true;\n          }\n        } else {\n          if (!fragments.hasOwnProperty(_key) && !require('relay-runtime').isScalarAndEqual(nextProps[_key], this.props[_key])) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    };\n    /**\n     * Render new data for the existing props/context.\n     */\n\n\n    Container.prototype._rerenderIfStoreHasChanged = function _rerenderIfStoreHasChanged() {\n      var _state = this.state,\n          data = _state.data,\n          resolver = _state.resolver; // External values could change between render and commit.\n      // Check for this case, even though it requires an extra store read.\n\n      var maybeNewData = resolver.resolve();\n\n      if (data !== maybeNewData) {\n        this.setState({\n          data: maybeNewData\n        });\n      }\n    };\n\n    Container.prototype._subscribeToNewResolver = function _subscribeToNewResolver() {\n      var resolver = this.state.resolver; // Event listeners are only safe to add during the commit phase,\n      // So they won't leak if render is interrupted or errors.\n\n      resolver.setCallback(this._handleFragmentDataUpdate);\n    };\n\n    Container.prototype.render = function render() {\n      var _props = this.props,\n          componentRef = _props.componentRef,\n          props = (0, _objectWithoutProperties3['default'])(_props, ['componentRef']);\n      return require('react').createElement(Component, (0, _extends3['default'])({}, props, this.state.data, {\n        ref: componentRef,\n        relay: this.state.relayProp\n      }));\n    };\n\n    return Container;\n  }(require('react').Component);\n\n  Container.displayName = containerName;\n  Container.contextTypes = {\n    relay: require('./RelayPropTypes').Relay\n  };\n\n  require('./ReactRelayContainerProfiler').profileContainer(Container, 'ReactRelayFragmentContainer');\n\n  return Container;\n}\n/**\n * Wrap the basic `createContainer()` function with logic to adapt to the\n * `context.relay.environment` in which it is rendered. Specifically, the\n * extraction of the environment-specific version of fragments in the\n * `fragmentSpec` is memoized once per environment, rather than once per\n * instance of the container constructed/rendered.\n */\n\n\nfunction createContainer(Component, fragmentSpec) {\n  return require('./buildReactRelayContainer')(Component, fragmentSpec, createContainerWithFragments,\n  /* provides child context */\n  false);\n}\n\nmodule.exports = {\n  createContainer: createContainer,\n  createContainerWithFragments: createContainerWithFragments\n};","map":null,"metadata":{},"sourceType":"script"}