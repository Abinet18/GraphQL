{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n/**\n * Returns the values of field/fragment arguments as an object keyed by argument\n * names. Guaranteed to return a result with stable ordered nested values.\n */\n\nfunction getArgumentValues(args, variables) {\n  var values = {};\n  args.forEach(function (arg) {\n    if (arg.kind === require('./RelayConcreteNode').VARIABLE) {\n      // Variables are provided at runtime and are not guaranteed to be stable.\n      values[arg.name] = getStableVariableValue(arg.variableName, variables);\n    } else {\n      // The Relay compiler generates stable ConcreteArgument values.\n      values[arg.name] = arg.value;\n    }\n  });\n  return values;\n}\n/**\n * Given a handle field and variable values, returns a key that can be used to\n * uniquely identify the combination of the handle name and argument values.\n *\n * Note: the word \"storage\" here refers to the fact this key is primarily used\n * when writing the results of a key in a normalized graph or \"store\". This\n * name was used in previous implementations of Relay internals and is also\n * used here for consistency.\n */\n\n\nfunction getHandleStorageKey(handleField, variables) {\n  var handle = handleField.handle,\n      key = handleField.key,\n      name = handleField.name,\n      args = handleField.args,\n      filters = handleField.filters;\n\n  var handleName = require('./getRelayHandleKey')(handle, key, name);\n\n  if (!args || !filters || args.length === 0 || filters.length === 0) {\n    return handleName;\n  }\n\n  var filterArgs = args.filter(function (arg) {\n    return filters.indexOf(arg.name) > -1;\n  });\n  return formatStorageKey(handleName, getArgumentValues(filterArgs, variables));\n}\n/**\n * Given a field and variable values, returns a key that can be used to\n * uniquely identify the combination of the field name and argument values.\n *\n * Note: the word \"storage\" here refers to the fact this key is primarily used\n * when writing the results of a key in a normalized graph or \"store\". This\n * name was used in previous implementations of Relay internals and is also\n * used here for consistency.\n */\n\n\nfunction getStorageKey(field, variables) {\n  if (field.storageKey) {\n    // TODO T23663664: Handle nodes do not yet define a static storageKey.\n    return field.storageKey;\n  }\n\n  var args = field.args,\n      name = field.name;\n  return args && args.length !== 0 ? formatStorageKey(name, getArgumentValues(args, variables)) : name;\n}\n/**\n * Given a `name` (eg. \"foo\") and an object representing argument values\n * (eg. `{orberBy: \"name\", first: 10}`) returns a unique storage key\n * (ie. `foo{\"first\":10,\"orderBy\":\"name\"}`).\n *\n * This differs from getStorageKey which requires a ConcreteNode where arguments\n * are assumed to already be sorted into a stable order.\n */\n\n\nfunction getStableStorageKey(name, args) {\n  return formatStorageKey(name, require('./stableCopy')(args));\n}\n/**\n * Given a name and argument values, format a storage key.\n *\n * Arguments and the values within them are expected to be ordered in a stable\n * alphabetical ordering.\n */\n\n\nfunction formatStorageKey(name, argValues) {\n  if (!argValues) {\n    return name;\n  }\n\n  var values = [];\n\n  for (var _argName in argValues) {\n    if (argValues.hasOwnProperty(_argName)) {\n      var value = argValues[_argName];\n\n      if (value != null) {\n        values.push(_argName + ':' + JSON.stringify(value));\n      }\n    }\n  }\n\n  return values.length === 0 ? name : name + ('(' + values.join(',') + ')');\n}\n/**\n * Given Variables and a variable name, return a variable value with\n * all values in a stable order.\n */\n\n\nfunction getStableVariableValue(name, variables) {\n  !variables.hasOwnProperty(name) ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'getVariableValue(): Undefined variable `%s`.', name) : require('fbjs/lib/invariant')(false) : void 0;\n  return require('./stableCopy')(variables[name]);\n}\n/**\n * Constants shared by all implementations of RecordSource/MutableRecordSource/etc.\n */\n\n\nvar RelayStoreUtils = {\n  FRAGMENTS_KEY: '__fragments',\n  ID_KEY: '__id',\n  REF_KEY: '__ref',\n  REFS_KEY: '__refs',\n  ROOT_ID: 'client:root',\n  ROOT_TYPE: '__Root',\n  TYPENAME_KEY: '__typename',\n  UNPUBLISH_RECORD_SENTINEL: Object.freeze({\n    __UNPUBLISH_RECORD_SENTINEL: true\n  }),\n  UNPUBLISH_FIELD_SENTINEL: Object.freeze({\n    __UNPUBLISH_FIELD_SENTINEL: true\n  }),\n  getArgumentValues: getArgumentValues,\n  getHandleStorageKey: getHandleStorageKey,\n  getStorageKey: getStorageKey,\n  getStableStorageKey: getStableStorageKey\n};\nmodule.exports = RelayStoreUtils;","map":null,"metadata":{},"sourceType":"script"}