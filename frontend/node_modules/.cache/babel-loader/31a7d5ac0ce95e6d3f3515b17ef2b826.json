{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nvar _extends3 = _interopRequireDefault(require('babel-runtime/helpers/extends'));\n\nvar _classCallCheck3 = _interopRequireDefault(require('babel-runtime/helpers/classCallCheck'));\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(require('babel-runtime/helpers/possibleConstructorReturn'));\n\nvar _inherits3 = _interopRequireDefault(require('babel-runtime/helpers/inherits'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar NETWORK_ONLY = 'NETWORK_ONLY';\nvar STORE_THEN_NETWORK = 'STORE_THEN_NETWORK';\nvar DataFromEnum = {\n  NETWORK_ONLY: NETWORK_ONLY,\n  STORE_THEN_NETWORK: STORE_THEN_NETWORK\n};\n/**\n * @public\n *\n * Orchestrates fetching and rendering data for a single view or view hierarchy:\n * - Fetches the query/variables using the given network implementation.\n * - Normalizes the response(s) to that query, publishing them to the given\n *   store.\n * - Renders the pending/fail/success states with the provided render function.\n * - Subscribes for updates to the root data and re-renders with any changes.\n */\n\nvar ReactRelayQueryRenderer = function (_React$Component) {\n  (0, _inherits3['default'])(ReactRelayQueryRenderer, _React$Component); // TODO T25783053 Update this component to use the new React context API,\n  // Once we have confirmed that it's okay to raise min React version to 16.3.\n\n  function ReactRelayQueryRenderer(props, context) {\n    (0, _classCallCheck3['default'])(this, ReactRelayQueryRenderer); // Callbacks are attached to the current instance and shared with static\n    // lifecyles by bundling with state. This is okay to do because the\n    // callbacks don't change in reaction to props. However we should not\n    // \"leak\" them before mounting (since we would be unable to clean up). For\n    // that reason, we define them as null initially and fill them in after\n    // mounting to avoid leaking memory.\n\n    var _this = (0, _possibleConstructorReturn3['default'])(this, _React$Component.call(this, props, context));\n\n    _this._relayContext = {\n      // $FlowFixMe TODO t16225453 QueryRenderer works with old+new environment.\n      environment: _this.props.environment,\n      variables: _this.props.variables\n    };\n    var retryCallbacks = {\n      handleDataChange: null,\n      handleRetryAfterError: null\n    };\n    var queryFetcher = new (require('./ReactRelayQueryFetcher'))();\n    _this.state = (0, _extends3['default'])({\n      prevPropsEnvironment: props.environment,\n      prevPropsVariables: props.variables,\n      prevQuery: props.query,\n      queryFetcher: queryFetcher,\n      retryCallbacks: retryCallbacks\n    }, fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks));\n    return _this;\n  }\n\n  ReactRelayQueryRenderer.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n    if (prevState.prevQuery !== nextProps.query || prevState.prevPropsEnvironment !== nextProps.environment || !require('fbjs/lib/areEqual')(prevState.prevPropsVariables, nextProps.variables)) {\n      return (0, _extends3['default'])({\n        prevQuery: nextProps.query,\n        prevPropsEnvironment: nextProps.environment,\n        prevPropsVariables: nextProps.variables\n      }, fetchQueryAndComputeStateFromProps(nextProps, prevState.queryFetcher, prevState.retryCallbacks));\n    }\n\n    return null;\n  };\n\n  ReactRelayQueryRenderer.prototype.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    var _state = this.state,\n        retryCallbacks = _state.retryCallbacks,\n        queryFetcher = _state.queryFetcher;\n\n    retryCallbacks.handleDataChange = function (params) {\n      var error = params.error == null ? null : params.error;\n      var snapshot = params.snapshot == null ? null : params.snapshot;\n\n      _this2.setState(function (prevState) {\n        // Don't update state if nothing has changed.\n        if (snapshot === prevState.snapshot && error === prevState.error) {\n          return null;\n        }\n\n        return {\n          renderProps: getRenderProps(error, snapshot, queryFetcher, retryCallbacks),\n          snapshot: snapshot\n        };\n      });\n    };\n\n    retryCallbacks.handleRetryAfterError = function (error) {\n      return _this2.setState({\n        renderProps: getLoadingRenderProps()\n      });\n    }; // Re-initialize the ReactRelayQueryFetcher with callbacks.\n    // If data has changed since constructions, this will re-render.\n\n\n    if (this.props.query) {\n      queryFetcher.setOnDataChange(retryCallbacks.handleDataChange);\n    }\n  };\n\n  ReactRelayQueryRenderer.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.state.queryFetcher.dispose();\n  };\n\n  ReactRelayQueryRenderer.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n    return nextProps.render !== this.props.render || nextState.renderProps !== this.state.renderProps;\n  };\n\n  ReactRelayQueryRenderer.prototype.getChildContext = function getChildContext() {\n    return {\n      relay: this._relayContext\n    };\n  };\n\n  ReactRelayQueryRenderer.prototype.render = function render() {\n    var _state2 = this.state,\n        relayContextEnvironment = _state2.relayContextEnvironment,\n        relayContextVariables = _state2.relayContextVariables,\n        renderProps = _state2.renderProps; // HACK Mutate the context.relay object before updating children,\n    // To account for any changes made by static gDSFP.\n    // Updating this value in gDSFP would be less safe, since props changes\n    // could be interrupted and we might re-render based on a setState call.\n    // Child containers rely on context.relay being mutated (also for gDSFP).\n    // $FlowFixMe TODO t16225453 QueryRenderer works with old+new environment.\n\n    this._relayContext.environment = relayContextEnvironment;\n    this._relayContext.variables = relayContextVariables; // Note that the root fragment results in `renderProps.props` is already\n    // frozen by the store; this call is to freeze the renderProps object and\n    // error property if set.\n\n    if (process.env.NODE_ENV !== 'production') {\n      require('relay-runtime').deepFreeze(renderProps);\n    }\n\n    return this.props.render(renderProps);\n  };\n\n  return ReactRelayQueryRenderer;\n}(require('react').Component);\n\nReactRelayQueryRenderer.childContextTypes = {\n  relay: require('./RelayPropTypes').Relay\n};\n\nfunction getLoadingRenderProps() {\n  return {\n    error: null,\n    props: null,\n    // `props: null` indicates that the data is being fetched (i.e. loading)\n    retry: null\n  };\n}\n\nfunction getEmptyRenderProps() {\n  return {\n    error: null,\n    props: {},\n    // `props: {}` indicates no data available\n    retry: null\n  };\n}\n\nfunction getRenderProps(error, snapshot, queryFetcher, retryCallbacks) {\n  return {\n    error: error ? error : null,\n    props: snapshot ? snapshot.data : null,\n    retry: function retry() {\n      var syncSnapshot = queryFetcher.retry();\n\n      if (syncSnapshot && typeof retryCallbacks.handleDataChange === 'function') {\n        retryCallbacks.handleDataChange({\n          snapshot: syncSnapshot\n        });\n      } else if (error && typeof retryCallbacks.handleRetryAfterError === 'function') {\n        // If retrying after an error and no synchronous result available,\n        // reset the render props\n        retryCallbacks.handleRetryAfterError(error);\n      }\n    }\n  };\n}\n\nfunction fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks) {\n  var environment = props.environment,\n      query = props.query,\n      variables = props.variables;\n\n  if (query) {\n    // $FlowFixMe TODO t16225453 QueryRenderer works with old+new environment.\n    var genericEnvironment = environment;\n    var _genericEnvironment$u = genericEnvironment.unstable_internal,\n        createOperationSelector = _genericEnvironment$u.createOperationSelector,\n        getRequest = _genericEnvironment$u.getRequest;\n    var request = getRequest(query);\n    var operation = createOperationSelector(request, variables);\n\n    try {\n      var storeSnapshot = props.dataFrom === STORE_THEN_NETWORK ? queryFetcher.lookupInStore(genericEnvironment, operation) : null;\n      var querySnapshot = queryFetcher.fetch({\n        cacheConfig: props.cacheConfig,\n        dataFrom: props.dataFrom,\n        environment: genericEnvironment,\n        onDataChange: retryCallbacks.handleDataChange,\n        operation: operation\n      }); // Use network data first, since it may be fresher\n\n      var _snapshot = querySnapshot || storeSnapshot;\n\n      if (!_snapshot) {\n        return {\n          error: null,\n          relayContextEnvironment: environment,\n          relayContextVariables: operation.variables,\n          renderProps: getLoadingRenderProps(),\n          snapshot: null\n        };\n      }\n\n      return {\n        error: null,\n        relayContextEnvironment: environment,\n        relayContextVariables: operation.variables,\n        renderProps: getRenderProps(null, _snapshot, queryFetcher, retryCallbacks),\n        snapshot: _snapshot\n      };\n    } catch (error) {\n      return {\n        error: error,\n        relayContextEnvironment: environment,\n        relayContextVariables: operation.variables,\n        renderProps: getRenderProps(error, null, queryFetcher, retryCallbacks),\n        snapshot: null\n      };\n    }\n  } else {\n    queryFetcher.dispose();\n    return {\n      error: null,\n      relayContextEnvironment: environment,\n      relayContextVariables: variables,\n      renderProps: getEmptyRenderProps()\n    };\n  }\n}\n\nmodule.exports = ReactRelayQueryRenderer;","map":null,"metadata":{},"sourceType":"script"}