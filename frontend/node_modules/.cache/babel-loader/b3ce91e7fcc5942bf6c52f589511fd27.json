{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nvar _objectWithoutProperties3 = _interopRequireDefault(require('babel-runtime/helpers/objectWithoutProperties'));\n\nvar _extends3 = _interopRequireDefault(require('babel-runtime/helpers/extends'));\n\nvar _classCallCheck3 = _interopRequireDefault(require('babel-runtime/helpers/classCallCheck'));\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(require('babel-runtime/helpers/possibleConstructorReturn'));\n\nvar _inherits3 = _interopRequireDefault(require('babel-runtime/helpers/inherits'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar containerContextTypes = {\n  relay: require('./RelayPropTypes').Relay\n};\n/**\n * Composes a React component class, returning a new class that intercepts\n * props, resolving them with the provided fragments and subscribing for\n * updates.\n */\n\nfunction createContainerWithFragments(Component, fragments, taggedNode) {\n  var containerName = require('./ReactRelayContainerUtils').getContainerName(Component);\n\n  var Container = function (_React$Component) {\n    (0, _inherits3['default'])(Container, _React$Component);\n\n    function Container(props, context) {\n      (0, _classCallCheck3['default'])(this, Container);\n\n      var _this = (0, _possibleConstructorReturn3['default'])(this, _React$Component.call(this, props, context));\n\n      _this._handleFragmentDataUpdate = function () {\n        var profiler = require('relay-runtime').RelayProfiler.profile('ReactRelayRefetchContainer.handleFragmentDataUpdate');\n\n        var resolverFromThisUpdate = _this.state.resolver;\n\n        _this.setState(function (updatedState) {\n          // If this event belongs to the current data source, update.\n          // Otherwise we should ignore it.\n          if (resolverFromThisUpdate === updatedState.resolver) {\n            return {\n              data: updatedState.resolver.resolve()\n            };\n          }\n\n          return null;\n        }, profiler.stop);\n      };\n\n      _this._refetch = function (refetchVariables, renderVariables, observerOrCallback, options) {\n        var _assertRelayContext = require('./RelayContext').assertRelayContext(_this.context.relay),\n            environment = _assertRelayContext.environment,\n            rootVariables = _assertRelayContext.variables;\n\n        var fetchVariables = typeof refetchVariables === 'function' ? refetchVariables(_this._getFragmentVariables()) : refetchVariables;\n        fetchVariables = (0, _extends3['default'])({}, rootVariables, fetchVariables);\n        var fragmentVariables = renderVariables ? (0, _extends3['default'])({}, rootVariables, renderVariables) : fetchVariables;\n        var cacheConfig = options ? {\n          force: !!options.force\n        } : undefined;\n        var observer = typeof observerOrCallback === 'function' ? {\n          // callback is not exectued on complete or unsubscribe\n          // for backward compatibility\n          next: observerOrCallback,\n          error: observerOrCallback\n        } : observerOrCallback || {};\n        var _this$context$relay$e = _this.context.relay.environment.unstable_internal,\n            createOperationSelector = _this$context$relay$e.createOperationSelector,\n            getRequest = _this$context$relay$e.getRequest;\n        var query = getRequest(taggedNode);\n        var operation = createOperationSelector(query, fetchVariables); // TODO: T26288752 find a better way\n\n        /* eslint-disable lint/react-state-props-mutation */\n\n        _this.state.localVariables = fetchVariables;\n        /* eslint-enable lint/react-state-props-mutation */\n        // Cancel any previously running refetch.\n\n        _this._refetchSubscription && _this._refetchSubscription.unsubscribe(); // Declare refetchSubscription before assigning it in .start(), since\n        // synchronous completion may call callbacks .subscribe() returns.\n\n        var refetchSubscription = void 0;\n\n        _this._getQueryFetcher().execute({\n          environment: environment,\n          operation: operation,\n          cacheConfig: cacheConfig,\n          // TODO (T26430099): Cleanup old references\n          preservePreviousReferences: true\n        }).mergeMap(function (response) {\n          // Child containers rely on context.relay being mutated (for gDSFP).\n          // TODO: T26288752 find a better way\n\n          /* eslint-disable lint/react-state-props-mutation */\n          _this.state.relayContext.environment = _this.context.relay.environment;\n          _this.state.relayContext.variables = fragmentVariables;\n          /* eslint-enable lint/react-state-props-mutation */\n\n          _this.state.resolver.setVariables(fragmentVariables);\n\n          return require('relay-runtime').Observable.create(function (sink) {\n            return _this.setState({\n              data: _this.state.resolver.resolve()\n            }, function () {\n              sink.next();\n              sink.complete();\n            });\n          });\n        })['finally'](function () {\n          // Finalizing a refetch should only clear this._refetchSubscription\n          // if the finizing subscription is the most recent call.\n          if (_this._refetchSubscription === refetchSubscription) {\n            _this._refetchSubscription = null;\n          }\n        }).subscribe((0, _extends3['default'])({}, observer, {\n          start: function start(subscription) {\n            _this._refetchSubscription = refetchSubscription = subscription;\n            observer.start && observer.start(subscription);\n          }\n        }));\n\n        return {\n          dispose: function dispose() {\n            refetchSubscription && refetchSubscription.unsubscribe();\n          }\n        };\n      };\n\n      var relay = require('./RelayContext').assertRelayContext(context.relay);\n\n      var createFragmentSpecResolver = relay.environment.unstable_internal.createFragmentSpecResolver;\n      _this._refetchSubscription = null; // Do not provide a subscription/callback here.\n      // It is possible for this render to be interrupted or aborted,\n      // In which case the subscription would cause a leak.\n      // We will add the subscription in componentDidMount().\n\n      var resolver = createFragmentSpecResolver(relay, containerName, fragments, props);\n      _this.state = {\n        data: resolver.resolve(),\n        localVariables: null,\n        relay: relay,\n        relayContext: {\n          environment: relay.environment,\n          variables: relay.variables\n        },\n        relayEnvironment: relay.environment,\n        relayProp: {\n          environment: relay.environment,\n          refetch: _this._refetch\n        },\n        prevProps: _this.props,\n        relayVariables: relay.variables,\n        resolver: resolver\n      };\n      return _this;\n    }\n\n    Container.prototype.componentDidMount = function componentDidMount() {\n      this._subscribeToNewResolver();\n    };\n\n    Container.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n      // If the environment has changed or props point to new records then\n      // previously fetched data and any pending fetches no longer apply:\n      // - Existing references are on the old environment.\n      // - Existing references are based on old variables.\n      // - Pending fetches are for the previous records.\n      if (this.state.resolver !== prevState.resolver) {\n        prevState.resolver.dispose();\n        this._queryFetcher && this._queryFetcher.dispose();\n        this._refetchSubscription && this._refetchSubscription.unsubscribe();\n\n        this._subscribeToNewResolver();\n      }\n    };\n    /**\n     * When new props are received, read data for the new props and add it to\n     * state. Props may be the same in which case previous data can be reused.\n     */\n\n\n    Container.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      // Any props change could impact the query, so we mirror props in state.\n      // This is an unusual pattern, but necessary for this container usecase.\n      var prevProps = prevState.prevProps;\n\n      var relay = require('./RelayContext').assertRelayContext(prevState.relay);\n\n      var _relay$environment$un = relay.environment.unstable_internal,\n          createFragmentSpecResolver = _relay$environment$un.createFragmentSpecResolver,\n          getDataIDsFromObject = _relay$environment$un.getDataIDsFromObject;\n      var prevIDs = getDataIDsFromObject(fragments, prevProps);\n      var nextIDs = getDataIDsFromObject(fragments, nextProps);\n      var resolver = prevState.resolver; // If the environment has changed or props point to new records then\n      // previously fetched data and any pending fetches no longer apply:\n      // - Existing references are on the old environment.\n      // - Existing references are based on old variables.\n      // - Pending fetches are for the previous records.\n\n      if (prevState.relayEnvironment !== relay.environment || prevState.relayVariables !== relay.variables || !require('fbjs/lib/areEqual')(prevIDs, nextIDs)) {\n        // Child containers rely on context.relay being mutated (for gDSFP).\n        var mutatedRelayContext = prevState.relayContext;\n        mutatedRelayContext.environment = relay.environment;\n        mutatedRelayContext.variables = relay.variables; // Do not provide a subscription/callback here.\n        // It is possible for this render to be interrupted or aborted,\n        // In which case the subscription would cause a leak.\n        // We will add the subscription in componentDidUpdate().\n\n        resolver = createFragmentSpecResolver(relay, containerName, fragments, nextProps);\n        return {\n          data: resolver.resolve(),\n          localVariables: null,\n          prevProps: nextProps,\n          relayContext: mutatedRelayContext,\n          relayEnvironment: relay.environment,\n          relayProp: {\n            environment: relay.environment,\n            // refetch should never really change\n            refetch: prevState.relayProp.refetch\n          },\n          relayVariables: relay.variables,\n          resolver: resolver\n        };\n      } else if (!prevState.localVariables) {\n        resolver.setProps(nextProps);\n      }\n\n      var data = resolver.resolve();\n\n      if (data !== prevState.data) {\n        return {\n          data: data,\n          prevProps: nextProps\n        };\n      }\n\n      return null;\n    };\n\n    Container.prototype.componentWillUnmount = function componentWillUnmount() {\n      this.state.resolver.dispose();\n      this._queryFetcher && this._queryFetcher.dispose();\n      this._refetchSubscription && this._refetchSubscription.unsubscribe();\n    };\n\n    Container.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState, nextContext) {\n      // Short-circuit if any Relay-related data has changed\n      if (nextState.data !== this.state.data || nextState.relayProp !== this.state.relayProp) {\n        return true;\n      } // Otherwise, for convenience short-circuit if all non-Relay props\n      // are scalar and equal\n\n\n      var keys = Object.keys(nextProps);\n\n      for (var ii = 0; ii < keys.length; ii++) {\n        var _key = keys[ii];\n\n        if (_key === 'relay') {\n          if (nextState.relayEnvironment !== this.state.relayEnvironment || nextState.relayVariables !== this.state.relayVariables) {\n            return true;\n          }\n        } else {\n          if (!fragments.hasOwnProperty(_key) && !require('relay-runtime').isScalarAndEqual(nextProps[_key], this.props[_key])) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    };\n\n    Container.prototype._subscribeToNewResolver = function _subscribeToNewResolver() {\n      var _state = this.state,\n          data = _state.data,\n          resolver = _state.resolver; // Event listeners are only safe to add during the commit phase,\n      // So they won't leak if render is interrupted or errors.\n\n      resolver.setCallback(this._handleFragmentDataUpdate); // External values could change between render and commit.\n      // Check for this case, even though it requires an extra store read.\n\n      var maybeNewData = resolver.resolve();\n\n      if (data !== maybeNewData) {\n        this.setState({\n          data: maybeNewData\n        });\n      }\n    };\n    /**\n     * Render new data for the existing props/context.\n     */\n\n\n    Container.prototype._getFragmentVariables = function _getFragmentVariables() {\n      var getVariablesFromObject = this.context.relay.environment.unstable_internal.getVariablesFromObject;\n      return getVariablesFromObject(this.context.relay.variables, fragments, this.props);\n    };\n\n    Container.prototype._getQueryFetcher = function _getQueryFetcher() {\n      if (!this._queryFetcher) {\n        this._queryFetcher = new (require('./ReactRelayQueryFetcher'))();\n      }\n\n      return this._queryFetcher;\n    };\n\n    Container.prototype.getChildContext = function getChildContext() {\n      return {\n        relay: this.state.relayContext\n      };\n    };\n\n    Container.prototype.render = function render() {\n      var _props = this.props,\n          componentRef = _props.componentRef,\n          props = (0, _objectWithoutProperties3['default'])(_props, ['componentRef']);\n      return require('react').createElement(Component, (0, _extends3['default'])({}, props, this.state.data, {\n        ref: componentRef,\n        relay: this.state.relayProp\n      }));\n    };\n\n    return Container;\n  }(require('react').Component);\n\n  Container.displayName = containerName;\n  Container.contextTypes = containerContextTypes;\n\n  require('./ReactRelayContainerProfiler').profileContainer(Container, 'ReactRelayRefetchContainer');\n\n  return Container;\n}\n/**\n * Wrap the basic `createContainer()` function with logic to adapt to the\n * `context.relay.environment` in which it is rendered. Specifically, the\n * extraction of the environment-specific version of fragments in the\n * `fragmentSpec` is memoized once per environment, rather than once per\n * instance of the container constructed/rendered.\n */\n\n\nfunction createContainer(Component, fragmentSpec, taggedNode) {\n  return require('./buildReactRelayContainer')(Component, fragmentSpec, function (ComponentClass, fragments) {\n    return createContainerWithFragments(ComponentClass, fragments, taggedNode);\n  },\n  /* provides child context */\n  true);\n}\n\nmodule.exports = {\n  createContainer: createContainer,\n  createContainerWithFragments: createContainerWithFragments\n};","map":null,"metadata":{},"sourceType":"script"}